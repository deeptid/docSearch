a search engine is an information retrieval software program that discovers, crawls, transforms and stores information for retrieval and presentation in response to user queries.[1]  or  a search engine is a web based tool that enable user to locate information on www.[2]  a search engine normally  consists of four components e.g. search interface, crawler (also known as a spider or bot),indexer, and database. the crawler traverses a document collection, deconstructs document text, and assigns surrogates for storage in the search engine index. online search engines store images, link data and metadata for the document as well.  the concept of hypertext and a memory extension originates from an article that was published in the atlantic monthly in july 1945 written by vannevar bush, titled as we may think.  within this article vannevar urged scientists to work together to help build a body of knowledge for all mankind. he then proposed the idea of a virtually limitless, fast, reliable, extensible, associative memory storage and retrieval system. he named this device a memex.[3]  bush regarded the notion of “associative indexing” as his key conceptual contribution. as he explained, this was “a provision whereby any item may be caused at will to select immediately and automatically another. this is the essential feature of the memex. the process of tying two items together is the important thing.” this “linking” (as we now say) constituted a “trail” of documents that could be named, coded, and found again. moreover, after the original two items were coupled, “numerous items” could be “joined together to form a trail”; they could be “reviewed in turn, rapidly or slowly, by deflecting a lever like that used for turning the pages of a book. it is exactly as though the physical items had been gathered together from widely separated sources and bound together to form a new book”[4]  all of the documents used in the memex would be in the form of microfilm copy acquired as such or, in the case of personal records, transformed to microfilm by the machine itself. memex would also employ new retrieval techniques based on a new kind of associative indexing the basic idea of which is a provision whereby any item may be caused at will to select immediately and automatically another to create personal "trails" through linked documents. the new procedures, that bush anticipated facilitating information storage and retrieval would lead to the development of wholly new forms of encyclopedia.  the most important mechanism, conceived by bush and considered as closed to the modern hypertext systems is the associative trail. it would be a way to create a new linear sequence of microfilm frames across any arbitrary sequence of microfilm frames by creating a chained sequence of links in the way just described, along with personal comments and side trails.  the essential feature of the memex [is] the process of tying two items together... when the user is building a trail, he names it in his code book, and taps it out on his keyboard. before him are the two items to be joined, projected onto adjacent viewing positions. at the bottom of each there are a number of blank code spaces, and a pointer is set to indicate one of these on each item. the user taps a single key, and the items are permanently joined... thereafter, at any time, when one of these items is in view, the other can be instantly recalled merely by tapping a button below the corresponding code space.  in the article of bush is not described any automatic search, nor any universal metadata scheme such as a standard library classification or a hypertext element set. instead, when the user made an entry, such as a new or annotated manuscript, or image, he was expected to index and describe it in his personal code book. later on, by consulting his code book, the user could retrace annotated and generated entries.  in 1965 bush took part in the project intrex of mit, for developing technology for mechanization the processing of information for library use. in his 1967 essay titled "memex revisited", he pointed out that the development of the digital computer, the transistor, the video, and other similar devices had heightened the feasibility of such mechanization, but costs would delay its achievements. he was right again.  ted nelson, who later did pioneering work with first practical hypertext system and coined the term "hypertext" in the 1960s, credited bush as his main influence.[5]  gerard salton, who died on august 28 of 1995, was the father of modern search technology. his teams at harvard and cornell developed the smart informational retrieval system. salton's magic automatic retriever of text included important concepts like the vector space model, inverse document frequency (idf), term frequency (tf), term discrimination values, and relevancy feedback mechanisms.  he authored a 56-page book called a theory of indexing which explained many of his tests upon which search is still largely based.  in 1987 an article was published detailing the development of a character string search engine (sse) for rapid text retrieval on a double-metal 1.6-μm n-well cmos solid-state circuit with 217,600 transistors lain out on a 8.62x12.76-mm die area. the sse accommodated a novel string-search architecture which combines a 512-stage finite-state automaton (fsa) logic with a content addressable memory (cam) to achieve an approximate string comparison of 80 million strings per second. the cam cell consisted of four conventional static ram (sram) cells and a read/write circuit. concurrent comparison of 64 stored strings with variable length was achieved in 50 ns for an input text stream of 10 million characters/s, permitting performance despite the presence of single character errors in the form of character codes. furthermore, the chip allowed nonanchor string search and variable-length `don't care' (vldc) string search.[6]  the first web search engines was archie, created in 1990[7] by alan emtage, a student at mcgill university in montreal. the author originally wanted to call the program "archives," but had to shorten it to comply with the unix world standard of assigning programs and files short, cryptic names such as grep, cat, troff, sed, awk, perl, and so on.  the primary method of storing and retrieving files was via the file transfer protocol (ftp). this was (and still is) a system that specified a common way for computers to exchange files over the internet. it works like this: some administrator decides that he wants to make files available from his computer. he sets up a program on his computer, called an ftp server. when someone on the internet wants to retrieve a file from this computer, he or she connects to it via another program called an ftp client. any ftp client program can connect with any ftp server program as long as the client and server programs both fully follow the specifications set forth in the ftp protocol.  initially, anyone who wanted to share a file had to set up an ftp server in order to make the file available to others. later, "anonymous" ftp sites became repositories for files, allowing all users to post and retrieve them.  even with archive sites, many important files were still scattered on small ftp servers. unfortunately, these files could be located only by the internet equivalent of word of mouth: somebody would post an e-mail to a message list or a discussion forum announcing the availability of a file.  archie changed all that. it combined a script-based data gatherer, which fetched site listings of anonymous ftp files, with a regular expression matcher for retrieving file names matching a user query. (4) in other words, archie's gatherer scoured ftp sites across the internet and indexed all of the files it found. its regular expression matcher provided users with access to its database.[8]  in 1993, the university of nevada system computing services group developed veronica.[7] it was created as a type of searching device similar to archie but for gopher files. another gopher search service, called jughead, appeared a little later, probably for the sole purpose of rounding out the comic-strip triumvirate. jughead is an acronym for jonzy's universal gopher hierarchy excavation and display, although, like veronica, it is probably safe to assume that the creator backed into the acronym. jughead's functionality was pretty much identical to veronica's, although it appears to be a little rougher around the edges.[8]  the world wide web wanderer, developed by matthew gray in 1993[9] was the first robot on the web and was designed to track the web's growth. initially, the wanderer counted only web servers, but shortly after its introduction, it started to capture urls as it went along. the database of captured urls became the wandex, the first web database.  matthew gray's wanderer created quite a controversy at the time, partially because early versions of the software ran rampant through the net and caused a noticeable netwide performance degradation. this degradation occurred because the wanderer would access the same page hundreds of time a day. the wanderer soon amended its ways, but the controversy over whether robots were good or bad for the internet remained.  in response to the wanderer, martijn koster created archie-like indexing of the web, or aliweb, in october 1993. as the name implies, aliweb was the http equivalent of archie, and because of this, it is still unique in many ways.  aliweb does not have a web-searching robot. instead, webmasters of participating sites post their own index information for each page they want listed. the advantage to this method is that users get to describe their own site, and a robot doesn't run about eating up net bandwidth.  unfortunately, the disadvantages of aliweb are more of a problem today. the primary disadvantage is that a special indexing file must be submitted. most users do not understand how to create such a file, and therefore they don't submit their pages. this leads to a relatively small database, which meant that users are less likely to search aliweb than one of the large bot-based sites. this catch-22 has been somewhat offset by incorporating other databases into the aliweb search, but it still does not have the mass appeal of search engines such as yahoo! or lycos.[8]  excite, initially called architext, was started by six stanford undergraduates in february 1993. their idea was to use statistical analysis of word relationships in order to provide more efficient searches through the large amount of information on the internet.  their project was fully funded by mid-1993. once funding was secured. they released a version of their search software for webmasters to use on their own web sites. at the time, the software was called architext, but it now goes by the name of excite for web servers.[8]  excite was the first serious commercial search engine which launched in 1995.[10] it was developed in stanford and was purchased for $6.5 billion by @home. in 2001 excite and @home went bankrupt and infospace bought excite for $10 million.  some of the first analysis of web searching was conducted on search logs from excite[11][12]  in april 1994, two stanford university ph.d. candidates, david filo and jerry yang, created some pages that became rather popular. they called the collection of pages yahoo! their official explanation for the name choice was that they considered themselves to be a pair of yahoos.  as the number of links grew and their pages began to receive thousands of hits a day, the team created ways to better organize the data. in order to aid in data retrieval, yahoo! (www.yahoo.com) became a searchable directory. the search feature was a simple database search engine. because yahoo! entries were entered and categorized manually, yahoo! was not really classified as a search engine. instead, it was generally considered to be a searchable directory. yahoo! has since automated some aspects of the gathering and classification process, blurring the distinction between engine and directory.  the wanderer captured only urls, which made it difficult to find things that weren't explicitly described by their url. because urls are rather cryptic to begin with, this didn't help the average user. searching yahoo! or the galaxy was much more effective because they contained additional descriptive information about the indexed sites.  at carnegie mellon university during july 1994, michael mauldin, on leave from cmu,developed the lycos search engine.  search engines on the web are sites enriched with facility to search the content stored on other sites.  there is difference in the way various search engines work, but they all perform three basic tasks.[13]  the process begins when a user enters a query statement into the system through the interface provided.  there are basically three types of search engines: those that are powered by robots (called crawlers; ants or spiders) and those that are powered by human submissions; and those that are a hybrid of the two.  crawler-based search engines are those that use automated software agents (called crawlers) that visit a web site, read the information on the actual site, read the site's meta tags and also follow the links that the site connects to performing indexing on all linked web sites as well. the crawler returns all that information back to a central depository, where the data is indexed. the crawler will periodically return to the sites to check for any information that has changed. the frequency with which this happens is determined by the administrators of the search engine.  human-powered search engines rely on humans to submit information that is subsequently indexed and catalogued. only information that is submitted is put into the index.  in both cases, when you query a search engine to locate information, you're actually searching through the index that the search engine has created —you are not actually searching the web. these indices are giant databases of information that is collected and stored and subsequently searched. this explains why sometimes a search on a commercial search engine, such as yahoo! or google, will return results that are, in fact, dead links. since the search results are based on the index, if the index hasn't been updated since a web page became invalid the search engine treats the page as still an active link even though it no longer is. it will remain that way until the index is updated.  so why will the same search on different search engines produce different results? part of the answer to that question is because not all indices are going to be exactly the same. it depends on what the spiders find or what the humans submitted. but more important, not every search engine uses the same algorithm to search through the indices. the algorithm is what the search engines use to determine the relevance of the information in the index to what the user is searching for.  one of the elements that a search engine algorithm scans for is the frequency and location of keywords on a web page. those with higher frequency are typically considered more relevant. but search engine technology is becoming sophisticated in its attempt to discourage what is known as keyword stuffing, or spamdexing.  another common element that algorithms analyze is the way that pages link to other pages in the web. by analyzing how pages link to each other, an engine can both determine what a page is about (if the keywords of the linked pages are similar to the keywords on the original page) and whether that page is considered "important" and deserving of a boost in ranking. just as the technology is becoming increasingly sophisticated to ignore keyword stuffing, it is also becoming more savvy to web masters who build artificial links into their sites in order to build an artificial ranking.  modern web search engines are highly intricate software systems that employ technology that has evolved over the years. there are a number of sub-categories of search engine software that are separately applicable to specific 'browsing' needs. these include web search engines (e.g. google), database or structured data search engines (e.g. dieselpoint), and mixed search engines or enterprise search. the more prevalent search engines, such as google and yahoo!, utilize hundreds of thousands computers to process trillions of web pages in order to return fairly well-aimed results. due to this high volume of queries and text processing, the software is required to run in a highly dispersed environment with a high degree of superfluity.  search engines that are expressly designed for searching web pages, documents, and images were developed to facilitate searching through a large, nebulous blob of unstructured resources. they are engineered to follow a multi-stage process: crawling the infinite stockpile of pages and documents to skim the figurative foam from their contents, indexing the foam/buzzwords in a sort of semi-structured form (database or something), and at last, resolving user entries/queries to return mostly relevant results and links to those skimmed documents or pages from the inventory.  in the case of a wholly textual search, the first step in classifying web pages is to find an ‘index item’ that might relate expressly to the ‘search term.’ in the past, search engines began with a small list of urls as a so-called seed list, fetched the content, and parsed the links on those pages for relevant information, which subsequently provided new links. the process was highly cyclical and continued until enough pages were found for the searcher's use.  these days, a continuous crawl method is employed as opposed to an incidental discovery based on a seed list. the crawl method is an extension of aforementioned discovery method. except there is no seed list, because the system never stops worming.  most search engines use sophisticated scheduling algorithms to “decide” when to revisit a particular page, to appeal to its relevance. these algorithms range from constant visit-interval with higher priority for more frequently changing pages to adaptive visit-interval based on several criteria such as frequency of change, popularity, and overall quality of site. the speed of the web server running the page as well as resource constraints like amount of hardware or bandwidth also figure in.  the pages that are discovered by web crawls are often distributed and fed into another computer that creates a veritable map of resources uncovered. the bunchy clustermass looks a little like a graph, on which the different pages are represented as small nodes that are connected by  links between the pages.   the excess of data is stored in multiple data structures that permit quick access to said data by certain algorithms that compute the popularity score of pages on the web based on how many links point to a certain web page, which is how people can access any number of resources concerned with diagnosing psychosis. another example would be the accessibility/rank of web pages containing information on mohamed morsi versus the very best attractions to visit in cairo after simply entering ‘egypt’ as a search term. one such algorithm, pagerank, proposed by google founders larry page and sergey brin, is well known and has attracted a lot of attention because it highlights repeat mundanity of web searches courtesy of students that don't know how to properly research subjects on google.  the idea of doing link analysis to compute a popularity rank is older than pagerank. other variants of the same idea are currently in use – grade schoolers do the same sort of computations in picking kickball teams. but in all seriousness, these ideas can be categorized into three main categories: rank of individual pages and nature of web site content. search engines often differentiate between internal links and external links, because web masters and mistresses are not strangers to shameless self-promotion. link map data structures typically store the anchor text embedded in the links as well, because anchor text can often provide a “very good quality” summary of a web page's content.  searching for text-based content in databases presents a few special challenges from which a number of specialized search engines flourish. databases can be slow when solving complex queries (with multiple logical or string matching arguments). databases allow pseudo-logical queries which full-text searches do not use. there is no crawling necessary for a database since the data is already structured. however, it is often necessary to index the data in a more economized form to allow a more expeditious search.  sometimes, data searched contains both database content and web pages or documents. search engine technology has developed to respond to both sets of requirements. most mixed search engines are large web search engines, like google. they search both through structured and unstructured data sources. take for example, the word ‘ball.’ in its simplest terms, it returns more than 40 variations on wikipedia alone. did you mean a ball, as in the social gathering/dance? a soccer ball? the ball of the foot? pages and documents are crawled and indexed in a separate index. databases are indexed also from various sources. search results are then generated for users by querying these multiple indices in parallel and compounding the results according to “rules.”  